h3. Current goals

* -Sending packets.-
* -Set <code>main</code> to increment tos.-
* -Sending forth word.-
* -Sending numbers.-
* -Sending quotes.-
* -Storing forth word.-
* -VM words.-
* -VM numbers.-
* -VM quotes.-
* -Send execute word.-
* -kick instuction.-
* -VM save.-
* -VM load.-
* -Plaintext vm save/load.-
* -Document plaintext load.-
* -Dynamic kick from .so.-
* -Move udp to kick.so.-
* -No polling.-
* -Quoting words.-
* -Keyboard input.-
* -Alphasorted image.-
* -Fix stub for `word' to push correct address.-
* -Compiler.-
* -Conditional.-
* Buy a shovel.
* -Data words.-
* -Runtime-only data words.-
* -Conditional brackets.-
* Nested conditionals.
* Editor.
** Basic linear editor.
*** -@names@, @addrs@ and etc from forth.-
*** Runtime-only words.
*** @find@ on space
* JS interpreter.


h3. Network packet

Network packet for machine code and data consists of type byte, 16-bit data length, 8 word bytes and data bytes.

<pre><code>./ss 'A'  '*'  48 0f af 06  48 8d 76 04  c3
'A'  09 00  00 '*' 00 00 00 00 00 00   48 0f af 06  48 8d 76 04  c3</code></pre>

<pre><code>./ss 'D'  'data'  11 22 33 44
'D'  04 00  00 'd' 'a' 't' 'a' 00 00 00  11 22 33 44</code></pre>


Network packet for forth word consists of type byte, and 16-bit length of sequence and sequence of 8-byte names.
<pre><code>./ff 'fact [ drop $1 ] [ dup $1 - fact * ] dup $1 = if ;'
'F'  14 00  "fact" @2 "drop" $1 @5 "dup" $1... ";"</code></pre>


h3. Machine code words

<pre><code>* 48 0f af 06  48 8d 76 04  c3</code></pre>

Word @*@ associated with pointer to memory area holding raw bytes @48 0f@&hellip;

h3. Forth words

<pre><code>fact [ drop 1 ] [ dup 1 - fact * ] dup 1 = if ;</code></pre>

Word <code>fact</code> is associated with pointer to memory area holding vm execution prefix and 32-bit indexes and values.

<pre><code>e8 aa aa aa aa [@2] [drop] [$1] [@5] [dup] [$1] [-] [fact] [*] [dup] [$1] [=] [if] [;]</code></pre>

There is "kick" instruction in form of @^hexnumber@ it will execute @kick@ C function with number passed as argument,
function returns value on top of stack.

h3. Data words

<pre><code>data 11 22 33 44</code></pre>

Word <code>data</code> is associated with pointer to memory area holding data execution prefix and raw bytes <code>11 22</code>&hellip;

<pre><code>e8 bb bb bb bb 11 22 33 44</code></pre>

h3. VM

Each forth word is prefixed call to vm machine code so every word can be executed like ordinary machine code.

On entering in vm code top of return stack holds address of first forth word index on stack. So vm code need to lookup
address from def table and execute call to it. On return advance to next forth word and repeat.

On amd64 address of current forth word on top of return stack, %rdx is used for address resulution and for indirect call.

When assembler word is called return stack holds [ vm ret, forth word pointer ] so we need to pop both in ';' word.

h3. Save VM

VM is stored as plaintext. Loading is awful.


h3. Load VM

Characters from start till first whitespace are word name to define, then character after white space is type, then whitespace.

If type is 'F' then it depends on first character after whitespace. In case of @\@@, @$@ or @^@ trailing characeters until
whitespace compose hex number. Otherwise it is a name of word. Then whitespace and repeat.

If type is 'A' then two characters after whitespace are hex digits which compose byte. Then whitespace, and repeat.

If line feed character is seen in whitespace then it threated as whitespace but afterwards processing goes from start.

So states are:

Before type known:

- character of name
- whitespace (next is type)
- type character

For type 'F':

- whitespace
- first character of word
- character of hex number
- character of word

For type 'A':

- whitespace
- character of byte

h3. Editor

Hitting a key puts it in the word buffer. Hitting space applies word and
prints its definition.

Typing word name followed by return executes the word.

Typing word name followed by other words inserts them to a definition. By default words
are inserted at the beginning. Slashe at the end of word change place of insertion to
after next such word. Multiple @/@ select Nth next word.

Dash after slashes wipe word selected and more dashes wipe words after that.
Insertion will be done after wiped words. Lone slash sets insertion to the end of definition.

- @foo bar baz@ - word @foo@ is @bar baz ...@ now.
- @foo bar///---baz bar/baz@ - delete third @bar@ in @foo@, two words after it and put @baz@ on their
place; find next @bar@ and put @baz@ after it. 
- @foo/bar baz@ - word @foo@ is @... bar baz@ now.

