h3. Current goals

* -Sending packets.-
* -Set <code>main</code> to increment tos.-
* -Sending forth word.-
* -Sending numbers.-
* -Sending quotes.-
* -Storing forth word.-
* -VM words.-
* -VM numbers.-
* -VM quotes.-
* -Send execute word.-
* -kick instuction.-
* -VM save.-
* -VM load.-
* -Plaintext vm save/load.-
* -Document plaintext load.-
* -Dynamic kick from .so.-
* -Move udp to kick.so.-
* -No polling.-
* -Quoting words.-
* -Keyboard input.-
* -Alphasorted image.-
* -Fix stub for `word' to push correct address.-
* -Compiler.-
* -Conditional.-
* Buy a shovel.
* -Data words.-
* -Runtime-only data words.-
* -Conditional brackets.-
* -Nested conditionals.-
* -Reverse characters order in word to be TYPE D R O W.-
* Editor.
** Basic linear editor.
*** -Read word.-
*** -Display word typed.-
*** -Display word definition.-
*** -Separate display from input.-
*** -Replace word under cursor when typing.-
*** -Operators parsing.-
*** -Make compilation working.-
*** -{} put offset only, rest is compiled via inlines.-
*** Port word displaying to new dialect.
* JS interpreter.

h3. Quick Reference

All numbers in hex, 7 significant digits (start with zero if the first digit is a letter): @0deadbee@ @08@ @78@.

Everything starting with letters is word call: @word@ @hello@ @init@ @main@.

If word is prepended with dot it's a jump not call: @.recursive@ @.goaway@.

If number prepended with '^' it is a C call to kick.c: @^101@.

if word is prepended with single quote it will push word index in dictionary on stack: @'key@.

Special symbol @?@ checks ZF flag and jump if not zero to next @:@ symbol: @shl8 ? zero : notzero@. Note
that in case of zero both zero and nonzero will be executed (it is not if...else it's just if {}).

h3. Word types

*F* is a forth word.

*A* is a machine code.

*I* is a machine code which will be inlined.

*D* is a data word, on execution pointer to content will be pushed on stack.

*T* is a temporary data word, instead of data size is specified.

h3. Editor (new)

Actions:

* Create word (on colon).
* Cycle type (on consequent colons).
* Append to definition (on lexical boundary).

Input:

* *L*etters [a-z].
* *N*umbers [0-9A-F].
* *O*perators !"#$%&\'()*+,-./;<=>?@[\\]^_`{|}~
* *S*pecial [:]
* *W*hitespace [ \t\r\n]

On transitions:

1. LN LO LW NL NO NW OL ON OO OW - push first part into buffer and append buffer to current word.
2. LS - push first part into buffer, create word from buffer and set it to current.
3. LL - push first part into buffer.
4. NN - push first part into buffer.
5. NS OS WS - syntax error.
6. SS - cycle type of current word.
7. WW WL WN WO SL SN SO SW - do nothing.

On key:

* W: (1:LW NW OW)        (7:WW SW)
	WS -> (7)
	-> (1)
* L: (1:NL OL)    (3:LL) (7:WL SL)
	L -> (3)
	WS -> (7)
	-> (1)
* N: (1:LN ON)    (4:NN) (7:WN SN)
	N -> (4)
	WS -> (7)
	-> (1)
	
* O: (1:LO NO OO)        (7:WO SO)
	WS -> (7)
	-> (1)
	
* S: (2:LS)       (6:SS) (5:NS OS WS)
	L -> (2)
	S -> (6)
	-> (5)

h3. Editor (small)

Two states - word selection and word editing. Both operates on words.

On space in selection mode editor goes to edit mode. In editor mode it replaces word under cursor and goes right.

On letter key in both modes letter is pushed into word.

On question mark in selection mode word definition displayed. In editor mode word definition displayed or if no word
conditional is written.

Return key - in both modes everything is reset.

h3. Editor

Hitting a key puts it in the word buffer. Hitting space applies word and
prints its definition.

Typing word name followed by return executes the word.

Typing word name followed by other words inserts them to a definition. By default words
are inserted at the beginning. Slashe at the end of word change place of insertion to
after next such word. Multiple @/@ select Nth next word.

Dash after slashes wipe word selected and more dashes wipe words after that.
Insertion will be done after wiped words. Lone slash sets insertion to the end of definition.

- @foo bar baz@ - word @foo@ is @bar baz ...@ now.
- @foo bar///---baz bar/baz@ - delete third @bar@ in @foo@, two words after it and put @baz@ on their
place; find next @bar@ and put @baz@ after it. 
- @foo/bar baz@ - word @foo@ is @... bar baz@ now.

